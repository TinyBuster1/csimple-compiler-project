Terminals unused in grammar

   T_BOOLEAN
   T_CHAR
   T_VOID
   T_INTEGER
   T_STRING
   T_P_INT
   T_P_CHAR
   T_NULL
   OP_AND
   OP_DIVIDE
   OP_ASSIGMENT
   OP_EQUAL
   OP_GT
   OP_GTE
   OP_LT
   OP_LTE
   OP_MINUS
   OP_NOT
   OP_NOTEQUAL
   OP_OR
   OP_MUL
   OP_ADDRESS
   OP_CONTENT
   C_IF
   C_ELSE
   L_WHILE
   L_DOWHILE
   L_FOR
   K_RETURN
   LT_TRUE
   T_FASLE
   LT_CHAR
   LT_IDEN
   STRING_LITERAL
   LT_HEX
   LT_OCT
   LT_BIN
   T_SEMICOLON
   T_COLON
   T_COMMA
   T_OPENBRACKET
   T_CLOSEBRACKET
   T_OPENPAREN
   T_CLOSEPAREN
   T_VERT_BAR
   T_R_BRACKET
   T_L_BRACKET


Grammar

    0 $accept: s $end

    1 s: expr
    2  | '\n'

    3 expr: expr OP_PLUS expr
    4     | LT_INTEGER


Terminals, with rules where they appear

$end (0) 0
'\n' (10) 2
error (256)
T_BOOLEAN (258)
T_CHAR (259)
T_VOID (260)
T_INTEGER (261)
T_STRING (262)
T_P_INT (263)
T_P_CHAR (264)
T_NULL (265)
OP_AND (266)
OP_DIVIDE (267)
OP_ASSIGMENT (268)
OP_EQUAL (269)
OP_GT (270)
OP_GTE (271)
OP_LT (272)
OP_LTE (273)
OP_MINUS (274)
OP_NOT (275)
OP_NOTEQUAL (276)
OP_OR (277)
OP_PLUS (278) 3
OP_MUL (279)
OP_ADDRESS (280)
OP_CONTENT (281)
C_IF (282)
C_ELSE (283)
L_WHILE (284)
L_DOWHILE (285)
L_FOR (286)
K_RETURN (287)
LT_TRUE (288)
T_FASLE (289)
LT_CHAR (290)
LT_IDEN (291)
STRING_LITERAL (292)
LT_HEX (293)
LT_OCT (294)
LT_INTEGER (295) 4
LT_BIN (296)
T_SEMICOLON (297)
T_COLON (298)
T_COMMA (299)
T_OPENBRACKET (300)
T_CLOSEBRACKET (301)
T_OPENPAREN (302)
T_CLOSEPAREN (303)
T_VERT_BAR (304)
T_R_BRACKET (305)
T_L_BRACKET (306)


Nonterminals, with rules where they appear

$accept (53)
    on left: 0
s (54)
    on left: 1 2, on right: 0
expr (55)
    on left: 3 4, on right: 1 3


State 0

    0 $accept: . s $end

    LT_INTEGER  shift, and go to state 1
    '\n'        shift, and go to state 2

    s     go to state 3
    expr  go to state 4


State 1

    4 expr: LT_INTEGER .

    $default  reduce using rule 4 (expr)


State 2

    2 s: '\n' .

    $default  reduce using rule 2 (s)


State 3

    0 $accept: s . $end

    $end  shift, and go to state 5


State 4

    1 s: expr .
    3 expr: expr . OP_PLUS expr

    OP_PLUS  shift, and go to state 6

    $default  reduce using rule 1 (s)


State 5

    0 $accept: s $end .

    $default  accept


State 6

    3 expr: expr OP_PLUS . expr

    LT_INTEGER  shift, and go to state 1

    expr  go to state 7


State 7

    3 expr: expr . OP_PLUS expr
    3     | expr OP_PLUS expr .

    $default  reduce using rule 3 (expr)
